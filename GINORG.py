from cgitb import text
from logging import error, fatal, log
from asyncio.runners import run
from tkinter.tix import TEXT
import typing 
import keyboard
from colorama import Fore
import pyqrcode
from pyqrcode import QRCode
from tqdm import tqdm, trange
from time import sleep
from sys import prefix
from aiohttp import helpers
import discord
import youtube_dl
from discord import client
from discord import channel
from discord import user
from discord import embeds
from discord import member
from discord import message
from discord.ext import commands
import requests
from discord.utils import get
from discord import FFmpegPCMAudio
from discord import TextChannel
from youtube_dl import YoutubeDL
from discord import guild
from discord import voice_client
from discord.activity import Activity
from discord.colour import Color
from discord.ext import commands
import aiohttp
import json
from discord.utils import get
from discord.ext.commands.bot import Bot
import asyncio
import functools
import itertools
import math
import random
import urllib
import re
from discord.ext import commands
from discord import Embed
from aiohttp import ClientSession
import datetime
from datetime import datetime
import discord
import discordSuperUtils
from discord import FFmpegPCMAudio, PCMVolumeTransformer
import sqlite3
import ffmpeg
import pafy
import time
import threading
import colorama
from async_timeout import timeout
import os
from os import system
from colorama import Fore
from colorama import init
from colorama import Fore
##



##
os.system("title Loading BOT Discord...")
print(f"{Fore.MAGENTA}")
progressbar = tqdm([2,4,6,8,9,10])
for item in progressbar:
    sleep(0.1)
    progressbar.set_description(' Loading: ')

from colorama import Fore
from tqdm import tqdm, trange
from time import sleep
import os
os.system("title Scaping Proxies...")
print(f"{Fore.MAGENTA}")
progressbar = tqdm([2,4,6,8,9,10,11,12,13,14,15])
for item in progressbar:
    sleep(0.1)
    progressbar.set_description(' Scaping Proxies... ')
from colorama import Fore
from tqdm import tqdm, trange
from time import sleep
import os
os.system("title Loading:")
print(f"{Fore.MAGENTA}")
progressbar = tqdm([1,2,3])
for item in progressbar:
    sleep(0.1)
    progressbar.set_description(' Loading... ')
from colorama import Fore
from tqdm import tqdm, trange
from time import sleep
import os

os.system("title Checking For Updates...")
print(f"{Fore.MAGENTA}")
progressbar = tqdm([1,2,])
for item in progressbar:
    sleep(0.1)
    progressbar.set_description(' Checking For Updates... ')
try:
    import requests
except:
    os.system("pip install requests")
    import requests
try:
    from requests import get
except:
    os.system("pip install requests")
    from requests import get

import threading

try:
    import colorama
except:
    os.system("pip install colorama")
    import colorama

try:
    import discord
except:
    os.system("pip install discord")
    import discord

from discord.ext import commands

try:
    import pyautogui
except:
    os.system("pip install pyautogui")
    import pyautogui

import time
import re

try:
    import http.client
except:
    os.system('pip install python-http-client')
    import http.client

import random

try:
    import json
except:
    os.system('pip install json')
    import json


try:
    import base64
except:
    os.system('pip install base64')
    import base64

import string
import sys
from colorama import Fore

try:
    import emoji as ej
except:
    os.system('pip install emoji')
    import emoji as ej

try:
    import websocket
except:
    os.system('pip install websocket')
    import websocket

try:
    import asyncio
except:
    os.system('pip install asyncio')
    import asyncio

try:
    from bs4 import BeautifulSoup
except:
    os.system('pip install beautifulsoup4')

try:
    from webdriver_manager.chrome import ChromeDriverManager
except:
    os.system('pip install webdriver-manager')
    from webdriver_manager.chrome import ChromeDriverManager

try:
    from PIL import Image
except:
    os.system('pip install pillow')
    from PIL import Image
try:
    import discum
except:
    os.system('pip install discum')
    import discum

try:
    from selenium import webdriver
except:
    os.system('pip install selenium')
    from selenium import webdriver
os.system("cls")
os.system("title RUN file All")
def bots():
 print(f"\nTEST")
print(f"{Fore.LIGHTMAGENTA_EX} █     █░▓█████  ██▓     ▄████▄   ▒█████   ███▄ ▄███▓   ▄▄▄█████▓ ▒█████       ▄████  ██▓ ███▄    █  ▒█████   ██▀███    ▄████{Fore.RESET}")
print(f"{Fore.LIGHTMAGENTA_EX}▓█░ █ ░█░▓█   ▀ ▓██▒    ▒██▀ ▀█  ▒██▒  ██▒▓██▒▀█▀ ██▒   ▓  ██▒ ▓▒▒██▒  ██▒    ██▒ ▀█▒▓██▒ ██ ▀█   █ ▒██▒  ██▒▓██ ▒ ██▒ ██▒ ▀█▒{Fore.RESET}")
print(f"{Fore.LIGHTMAGENTA_EX}▒█░ █ ░█ ▒███   ▒██░    ▒▓█    ▄ ▒██░  ██▒▓██    ▓██░   ▒ ▓██░ ▒░▒██░  ██▒   ▒██░▄▄▄░▒██▒▓██  ▀█ ██▒▒██░  ██▒▓██ ░▄█ ▒▒██░▄▄▄░{Fore.RESET}")
print(f"{Fore.LIGHTMAGENTA_EX}░█░ █ ░█ ▒▓█  ▄ ▒██░    ▒▓▓▄ ▄██▒▒██   ██░▒██    ▒██    ░ ▓██▓ ░ ▒██   ██░   ░▓█  ██▓░██░▓██▒  ▐▌██▒▒██   ██░▒██▀▀█▄  ░▓█  ██▓{Fore.RESET}")
print(f"{Fore.LIGHTMAGENTA_EX}░░██▒██▓ ░▒████▒░██████▒▒ ▓███▀ ░░ ████▓▒░▒██▒   ░██▒     ▒██▒ ░ ░ ████▓▒░   ░▒▓███▀▒░██░▒██░   ▓██░░ ████▓▒░░██▓ ▒██▒░▒▓███▀▒{Fore.RESET}")
print(f"{Fore.LIGHTMAGENTA_EX}░ ▓░▒ ▒  ░░ ▒░ ░░ ▒░▓  ░░ ░▒ ▒  ░░ ▒░▒░▒░ ░ ▒░   ░  ░     ▒ ░░   ░ ▒░▒░▒░     ░▒   ▒ ░▓  ░ ▒░   ▒ ▒ ░ ▒░▒░▒░ ░ ▒▓ ░▒▓░ ░▒   ▒ {Fore.RESET}")
print(f"{Fore.LIGHTMAGENTA_EX}  ▒ ░ ░   ░ ░  ░░ ░ ▒  ░  ░  ▒     ░ ▒ ▒░ ░  ░      ░       ░      ░ ▒ ▒░      ░   ░  ▒ ░░ ░░   ░ ▒░  ░ ▒ ▒░   ░▒ ░ ▒░  ░   ░ {Fore.RESET}")
print(f"{Fore.LIGHTMAGENTA_EX}  ░   ░     ░     ░ ░   ░        ░ ░ ░ ▒  ░      ░        ░      ░ ░ ░ ▒     ░ ░   ░  ▒ ░   ░   ░ ░ ░ ░ ░ ▒    ░░   ░ ░ ░   ░ {Fore.RESET}")
print(f"{Fore.LIGHTMAGENTA_EX}    ░       ░  ░    ░  ░░ ░          ░ ░         ░                   ░ ░           ░  ░           ░     ░ ░     ░           ░ {Fore.RESET} > instagram: o._.2q")
print(f"{Fore.LIGHTMAGENTA_EX}                        ░                                                                                                     {Fore.RESET}")
print(f'{Fore.WHITE}> Made by! ・Martin#5772{Fore.RESET}')
print(f'{Fore.WHITE}> https://github.com/{Fore.RESET}') 
print(f'{Fore.LIGHTMAGENTA_EX}════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════{Fore.RESET}')
print(
        f'{Fore.LIGHTMAGENTA_EX}[Enter]{Fore.RESET} All bot features')
ronung = input("[>] Press Enter :")
keyboard.add_hotkey('x + c', os.system('exit'))





if ronung == "":
 try:
    open('tokens.txt')
 except:
    open("tokens.txt", "w")
    print(f"[{Fore.GREEN}+{Fore.RESET}]A file named [token.txt] was created. the reason for creating the file is that it is important in the application, especially in the bot token\nPlease add your bot token in the file [token.txt]\nYou can now run the application without programming problems")
 try:
     open('url.txt')
 except:
     open("url.txt", "w")
     url = open("url.txt", "a")
     url.write("url bot")
     print(f"A file named [url.txt] was created")
 try:
     open('data.json')
 except:
     open("data.json", "w")
     dat = open("prefixes.json", "a")
     dat.write("Erorr. msg")
     print(f"[{Fore.GREEN}+{Fore.RESET}]")
 try:
     open('level.json')
 except:
     open("level.json", "w")
     lev = open("prefixes.json", "a")
     lev.write("{}")
     print(f"[{Fore.GREEN}+{Fore.RESET}]")
 try:
    open('prefixes.json')
 except:
     open("prefixes.json", "w")
     pre = open("prefixes.json", "a")
     pre.write("{}")
     print(f"[{Fore.GREEN}+{Fore.RESET}]")
 try:
     open('warns.json')
 except:
     open("warns.json", "w")
     war = open("warns.json", "a")
     war.write("{}")
     print(f"[{Fore.GREEN}+{Fore.RESET}]")
print(f"[{Fore.GREEN}+{Fore.RESET}] Please add your token for the bot")
print(f"[{Fore.RED}!{Fore.RESET}] Warning, if you are a guest of the token, do not add the token again, it will lead to a minor problem")
here = input("[>] Token for Bot: ")
mss = open("tokens.txt", "a")
mss.write(here)
mss.close()
R  = '\033[31m'
random_id_sleep = random.randint(2, 15)
time.sleep(random_id_sleep)
os.system("title exposed bot database")
# rept msg or command 
tokens = open('tokens.txt', 'r').read()#.splitlines()
URLBOT = open('url.txt', 'r').read()




client = discord.Client()
def get_prefix(client, message): ##first we define get_prefix
     with open('prefixes.json', 'r') as f: ##we open and read the prefixes.json, assuming it's in the same file
        prefixes = json.load(f) #load the json as prefixes
     return prefixes[str(message.guild.id)] #recieve the prefix for the guild id given
client = commands.Bot(
    command_prefix= (get_prefix),
    )
client.remove_command("help")

async def update_data(users, user):
    if not f'{user.id}' in users:
        users[f'{user.id}'] = {}
        users[f'{user.id}']['warns'] = 0
        users[f'{user.id}']['mod'] = []
        users[f'{user.id}']['reason'] = []
        users[f'{user.id}']['time'] = []
        users[f'{user.id}']['warn_id'] = []

async def add_warns(users, user, warns):
    users[f'{user.id}']['warns'] += warns


@client.event
async def on_guild_join(guild):
    with open('prefixes.json', 'r') as f:
        prefixes = json.load(f)
    
    prefixes[str(guild.id)] = '$'#default prefix
    print(f"[!+!] im join server. is name server {guild.name}")
    with open('prefixes.json', 'w') as f: #write in the prefix.json "message.guild.id": "bl!"
        json.dump(prefixes, f, indent=4) #the indent is to make everything look a bit neater

@client.event
async def on_member_join(member):
    with open('users.json', 'r') as f:
        users = json.load(f)
        print("[member join] ")
    await update_data(users, member)

@client.event
async def on_voice_state_update(member, before, after):
    if str(after.channel) == f'{room_create}':
        if str(after) != str(before):
            await after.channel.clone(name=f'{member}s channel')
            person_to_move = member
            channel_to_move_person_to_move_to = client.get_channel(f'{member}s channel')
            await client.move_member(person_to_move, channel_to_move_person_to_move_to)
@client.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.MissingRequiredArgument):
        print(f'[{Fore.RED}Erorr{Fore.RESET}] The requirements will not be met., {ctx.author.name}')

    if isinstance(error, commands.MissingPermissions):
        print(f"[{Fore.RED}Erorr{Fore.RESET}] You dont have all the requirements, {ctx.author.name}")
        
    if isinstance(error, commands.CommandNotFound):
        print(f'[{Fore.RED}Erorr{Fore.RESET}] The command was written an error that did not exist in the system. The one who wrote the order is {ctx.author.id}')
     
    if isinstance(error, commands.CommandInvokeError):
        print(f"[{Fore.RED}Erorr{Fore.RESET}] A system error has occurred. The problem will be resolved as soon as possible, {ctx.author.name}")
@client.event
async def on_message(message):
    await client.process_commands(message)
    """ some on_message command """
    if message.author.id == client.user.id:
        return
    msg_content = message.content.lower()
    curseWord = ['كسم','كسمك','شرموط','شرموطة','مهبل','قحبة']

    if any(word in msg_content for word in curseWord):
        await message.delete()
        with open('warns.json', 'r') as f:
            users = json.load(f)
        user = message.author

        await update_data(users, user)
        await add_warns(users, user, 1)
        random_id = random.randint(10000, 99999)
        warndate = time.strftime("%A, %B %d %Y @ %H:%M:%S %p")
        warnss = users[f'{user.id}']['warns']
        users[f'{user.id}']['mod'].append(user.id)
        users[f'{user.id}']['reason'].append('1333')
        users[f'{user.id}']['time'].append(warndate)
        users[f'{user.id}']['warn_id'].append(random_id)
        dm = await client.fetch_user(user.id)
        em=discord.Embed(title="Warning", description=f"Server: {user.guild.name}\nReason: قذف\nWarning count: {warnss}",color=0xFF0000)
        em.set_thumbnail(url=user.guild.icon_url)
        em.set_footer(text=f"{warndate}")
        await dm.send(embed=em)
        with open('warns.json', 'w') as f:
         json.dump(users, f, sort_keys=True, ensure_ascii=False, indent=4, default=str)
    if message.author == client.user:
     return
    
    if message.content.startswith("السلام عليكم"):
     await message.channel.send("وعليكم سلام ورحمت الله وبركاتة")
    if not message.author.bot:
        with open('level.json','r') as f:
            users = json.load(f)
        await update_dat(users, message.author,message.guild)
        await add_experience(users, message.author, 1, message.guild)
        await level_up(users, message.author,message.channel, message.guild)

        with open('level.json','w') as f:
            json.dump(users, f)



async def update_dat(users, user,server):
    if not str(server.id) in users:
        users[str(server.id)] = {}
        if not str(user.id) in users[str(server.id)]:
            users[str(server.id)][str(user.id)] = {}
            users[str(server.id)][str(user.id)]['experience'] = 0
            users[str(server.id)][str(user.id)]['level'] = 1
    elif not str(user.id) in users[str(server.id)]:
            users[str(server.id)][str(user.id)] = {}
            users[str(server.id)][str(user.id)]['experience'] = 0
            users[str(server.id)][str(user.id)]['level'] = 1

async def add_experience(users, user, exp, server):
  users[str(user.guild.id)][str(user.id)]['experience'] += exp

async def level_up(users, user, channel, server):
  experience = users[str(user.guild.id)][str(user.id)]['experience']
  lvl_start = users[str(user.guild.id)][str(user.id)]['level']
  lvl_end = int(experience ** (1/4))
  if str(user.guild.id) != '757383943116030074':
    if lvl_start < lvl_end:
      #embed=discord.Embed(title='{}: has leveled up to Level {}'.format(user.name, lvl_end),colour=discord.Colour.random())
      #await channel.send(embed=embed)
      users[str(user.guild.id)][str(user.id)]['level'] = lvl_end

@client.event
async def on_guild_remove(guild): #when the bot is removed from the guild
    with open('prefixes.json', 'r') as f: #read the file
        prefixes = json.load(f)

    prefixes.pop(str(guild.id)) #find the guild.id that bot was removed from

    with open('prefixes.json', 'w') as f: #deletes the guild.id as well as its prefix
        json.dump(prefixes, f, indent=4)

@client.event
async def on_ready():
    os.system('cls')
    print("After a minute, the bot will be running!")
    print(f"Attempt to login <: {client.user}")
    time.sleep(5)
    print("Made by me : ! ・Martin#5772")
    time.sleep(10)
    print(f'')
    print('You are logged in successfully (How much is the login rate? = %100 )')
    print("                                                                    ")
    print("                    ＢＯＴ ＩＮＦＯＲＭＡＴＩＯＮ                      ")
    print("                                                                    ")
    print(f"username: {client.user}                                            ")
    print(f"ID : {client.user.id}                                              ")
    print(f"prefix : $                                                         ")
    print(f"version discord [BOT] : {discord.__version__}                      ")
    print(f"Login token [BOT] : {tokens}                                       ")
    print(f"URL Invite [BOT] : {URLBOT}")
    print(f"{Fore.LIGHTMAGENTA_EX}════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════{Fore.RESET}")
    activity = discord.Activity(type=discord.ActivityType.watching, name =("$help"))
@client.command()
async def help(ctx):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [help], {ctx.author.name}")
    embed=discord.Embed(title="help commands list", url=f"https://discord.com/api/oauth2/authorize?client_id={client.user.id}&permissions=1644972474359&scope=bot", color=0x0055ff)
    embed.set_author(name=f"{client.user}", url=f"https://discord.com/api/oauth2/authorize?client_id={client.user.id}&permissions=1644972474359&scope=bot", icon_url=client.user.avatar_url)
    embed.set_thumbnail(url="https://cdn.discordapp.com/attachments/919185341380960267/929728721273896990/images.jpeg")
    embed.add_field(name="`helpsystem`", value="**This command will show you all the system . commands**", inline=True)
    embed.add_field(name="`helpticket`", value="**This command will show you all ticket . commands**", inline=True)
    embed.add_field(name="`helpimg`", value="**This command will show you all image . commands**", inline=True)
    embed.add_field(name="`helpmusic`", value="**This command will show you all Music . commands**", inline=True)
    embed.add_field(name="`information`", value="**It shows you the bot maker's information and it shows the bot's information**", inline=True)
    await ctx.send(embed=embed)
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
    await ctx.message.add_reaction("✅")
@client.command()
async def information(ctx):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [information], {ctx.author.id}")
    print(f"[{Fore.GREEN}info{Fore.RESET}] name ; {ctx.author.name}\n{Fore.GREEN}├{Fore.RESET}servar ; {ctx.guild.name}\n{Fore.GREEN}├{Fore.RESET}servar id ; {ctx.guild.id}\n{Fore.GREEN}└{Fore.RESET}id member; {ctx.author.id}")
    print(f"[]")
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")





@client.command()
async def helpsystem(ctx):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [helpsystem], {ctx.author.name}")
    embed=discord.Embed(title="help commands", color=0x0329e2)
    embed.set_author(name=f"{client.user}", icon_url=client.user.avatar_url)
    embed.set_thumbnail(url="https://cdn.discordapp.com/attachments/912776929436901387/929687675244519424/fec2b23d7ce3266f44a22c452f74970a.png")
    embed.add_field(name="`prefix`", value="**Prefix changes anything, for example (#,@,!,)**")
    embed.add_field(name="`role`", value="**This command you can give role and  remove  role.**")
    embed.add_field(name="`serverinfo`", value="**Shows you all server information**")
    embed.add_field(name="`clear`", value="**Cleans messages from a channel.**")
    embed.add_field(name="`lock`", value="**Disables @everyone from sending messages in spcific channel.**")
    embed.add_field(name="`unlock`", value="**Removes denied sending messages from @everyone in specific channel.**")
    embed.add_field(name="`create_role`", value="**Add a new roll**")
    embed.add_field(name="`kick`", value="**kicks a member**")
    embed.add_field(name="`ban`", value="**Bans a member.**")
    embed.add_field(name="`unban`", value="**Unbans a member.**")
    embed.add_field(name="`warn`", value="**Warns a member.**")
    embed.add_field(name="`warndetails`", value="**com**")
    embed.add_field(name="`user`", value="**Shows information, such as ID and join date, about yourself or a user.**")
    embed.add_field(name="`ping`", value="**Test the bots response time.**")
    embed.add_field(name="`nick`", value="**Change nickname on this server.**")
    embed.add_field(name="`avatar`", value="**Get a user's avatar**")
    embed.add_field(name="`level`", value="**command**")
    embed.set_footer(text=f"The prefix command $help")
    await ctx.message.add_reaction("✅")
    await ctx.send(embed=embed)
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
@client.command(pass_context=True,aliases=['تغير','pre'])#true
@commands.has_permissions(administrator=True) 
async def prefix(ctx, prefix): 
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [], {ctx.author.name}")
    if prefix is None:
        await ctx.send("You didn't set the prefix Please put the prefix")
    with open('prefixes.json', 'r') as f:
        prefixes = json.load(f)

    prefixes[str(ctx.guild.id)] = prefix

    with open('prefixes.json', 'w') as f: 
        json.dump(prefixes, f, indent=4)

    await ctx.send(f'Prefix changed to: {prefix}') 
    name=f'{prefix}BotBot'
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

@client.command(aliases=['info','si','infoser'])#true
async def serverinfo(ctx):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [], {ctx.author.name}")
    role_count = len(ctx.guild.roles)
    list_of_bots = [bot.mention for bot in ctx.guild.members if bot.bot]
    staff_roles = ["Owner", "Head Dev", "Dev", "Head Admin", "Admins", "Moderators", "Community Helpers", "Members"]
        
    embed2 = discord.Embed(timestamp=ctx.message.created_at, color=ctx.author.color)
    embed2.add_field(name='Name', value=f"{ctx.guild.name}", inline=False)
    embed2.add_field(name='Owner', value=f"{ctx.guild.owner}", inline=False)
    embed2.add_field(name='Verification Level', value=str(ctx.guild.verification_level), inline=False)
    embed2.add_field(name='Highest role', value=ctx.guild.roles[-1], inline=False)
    embed2.add_field(name='Contributers:', value="None")

    for r in staff_roles:
        role = discord.utils.get(ctx.guild.roles, name=r)
        if role:
            members = '\n'.join([member.name for member in role.members]) or "None"
            embed2.add_field(name=role.name, value=members)

    embed2.add_field(name='Number of roles', value=str(role_count), inline=False)
    embed2.add_field(name='Number Of Members', value=ctx.guild.member_count, inline=False)
    embed2.add_field(name='Bots:', value=(', '.join(list_of_bots)))
    embed2.add_field(name='Created At', value=ctx.guild.created_at.__format__('%A, %d. %B %Y @ %H:%M:%S'), inline=False)
    embed2.set_thumbnail(url=ctx.guild.icon_url)
    embed2.set_author(name=ctx.author.name, icon_url=ctx.author.avatar_url)
    embed2.set_footer(text=ctx.bot.user.name, icon_url=ctx.bot.user.avatar_url)

    await ctx.send(embed=embed2)
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

@client.command(name='clear',aliases=['حذف'])#true
@commands.has_permissions(manage_messages=True)
async def clear(ctx, amount: int):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [clear], {ctx.author.name}")
    authors = {}
    async for message in ctx.channel.history(limit=amount + 1):
        if message.author not in authors:
            authors[message.author] = 1
        else:
            authors[message.author] += 1
        await message.delete()

    msg = "\n".join([f"text: {author} , number: {amount}" for author,
                     amount in authors.items()])
    embed=discord.Embed(timestamp=ctx.message.created_at,title="Delete msg", description="", color=0xff0000)
    embed.add_field(name=f"{msg}", value="deleting", inline=False)
    embed.set_thumbnail(url=ctx.guild.icon_url)
    embed.set_author(name=ctx.author.name, icon_url=ctx.author.avatar_url)
    embed.set_footer(text=ctx.bot.user.name, icon_url=ctx.bot.user.avatar_url)
    await asyncio.sleep(3)
    await ctx.send(embed=embed)
    await asyncio.sleep(2)
    await ctx.delete(embed)
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

@client.command(name='lock',aliases=['قفل'])#true
@commands.has_permissions(manage_channels=True)
async def lock(ctx, channel : discord.TextChannel=None):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [lock], {ctx.author.name}")
    overwrite = ctx.channel.overwrites_for(ctx.guild.default_role)
    overwrite.send_messages = False
    await ctx.channel.set_permissions(ctx.guild.default_role, overwrite=overwrite)
    await ctx.send('Channel locked.')
@client.command(aliases=['فتح'])#true
@commands.has_permissions(manage_channels=True)
async def unlock(ctx):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [unlock], {ctx.author.name}")
    await ctx.channel.set_permissions(ctx.guild.default_role, send_messages=True)
    await ctx.send(ctx.channel.mention + " ***has been unlocked.***")
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
@lock.error
async def lock_error(ctx, error):
    if isinstance(error,commands.CheckFailure):
        await ctx.send('You do not have permission to use this command!')

@client.command(aliases=['رتبه'])#true
@commands.has_permissions(administrator=True)
async def role(ctx, user : discord.Member, *, role : discord.Role):
  print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [role], {ctx.author.name}")
  if role.position > ctx.author.top_role.position:
    return await ctx.send('**:x: | That role is above your top role!**') 
  if role != ctx.guild.roles:
      guild = ctx.guild
      await guild.create_role(name=role)
      await ctx.send(f"**Added '{role}' to {user.mention}**")
  if role in user.roles:
      await user.remove_roles(role)
      await ctx.send(f"Removed {role} from {user.mention}")
      print(f"[{Fore.GREEN}info{Fore.RESET}]")
      print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
  else:
      await user.add_roles(role)
      await ctx.send(f"Added {role} to {user.mention}")
      await ctx.message.add_reaction("✅")
      print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")


@client.command(name='kick',aliases=['طرد'])#true
@commands.has_permissions(administrator=True)
async def kick(ctx, member: discord.Member, *, reason=None):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [kick], {ctx.author.name}")
    await member.kick(reason=reason)
    await ctx.send(f'User {member} has kicked.')
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
@client.command()#true
@commands.has_permissions(administrator=True)
async def ban(ctx, member:discord.User=None, *,reason =None):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [ban], {ctx.author.name}")
    if member == None or member == ctx.message.author:
        await ctx.channel.send("You cannot ban yourself")
        return
    if reason == None:
        reason = "For being a jerk!"
    message = f"You have been banned from {ctx.guild.name}."
    await member.send(message)
    await ctx.guild.ban(member, reason=reason)
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
    await ctx.channel.send(f"🛫.{member} is banned!")
@client.command(name="unban")#true
@commands.has_permissions(administrator = True)
async def _unban(ctx, id: int):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [unban], {ctx.author.name}")
    user = await client.fetch_user(id)
    await ctx.guild.unban(user)
    await ctx.send(f'Unbanned {user.mention}')
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
@client.command(pass_context=True)#true
@commands.has_permissions(manage_roles=True)
async def nick(ctx, member: discord.Member=None, *,nick=None):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [nick], {ctx.author.name}")

    if member == None:
        member = ctx.message.author
        await member.edit(nick=member.name)
        await ctx.send(f':white_check_mark: Your nickname has been reset {member.mention}')
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
        return
    if nick == None:
        await member.edit(nick=member.name)
        await ctx.send(f':white_check_mark:The members nickname has been reset {member.mention}')
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
    else:
        await member.edit(nick=nick)
        await ctx.send(f'Nickname was changed for {member.mention} ')
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

@client.command()#true
@commands.has_permissions(administrator=True)
async def warn(ctx, user:discord.Member, *, args):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [warn], {ctx.author.name}")
    reason = ''.join(args)
    with open('warns.json', 'r') as f:
        users = json.load(f)

    await update_data(users, user)
    await add_warns(users, user, 1)
    random_id = random.randint(10000, 99999)
    warndate = time.strftime("%A, %B %d %Y @ %H:%M:%S %p")
    warnss = users[f'{user.id}']['warns']
    users[f'{user.id}']['mod'].append(ctx.author.id)
    users[f'{user.id}']['reason'].append(reason)
    users[f'{user.id}']['time'].append(warndate)
    users[f'{user.id}']['warn_id'].append(random_id)
    dm = await client.fetch_user(user.id)
    em=discord.Embed(title="Warning", description=f"Server: {ctx.guild.name}\nReason: {args}\nWarning count: {warnss}",color=0xFF0000)
    em.set_thumbnail(url=ctx.guild.icon_url)
    em.set_footer(text=f"{warndate}")
    await dm.send(embed=em)
    await ctx.message.add_reaction("✅")

    with open('warns.json', 'w') as f:
         json.dump(users, f, sort_keys=True, ensure_ascii=False, indent=4, default=str)
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
@client.command(aliases=['warns','سجل'])#true
@commands.has_permissions(administrator=True)
async def warndetails(ctx, user:discord.Member):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [warndetails , warn=], {ctx.author.name}")
    if user == ctx:
         await ctx.send("i dont can gef warns for you")

    if user == None:
        await ctx.send("[Erorr] plass gef me user member")
        
    
    with open('warns.json', 'r') as f:
     users = json.load(f)

    warns = users[f'{user.id}']['warns']
    moderator = users[f'{user.id}']['mod']
    warn_reason = users[f'{user.id}']['reason']
    warn_time = users[f'{user.id}']['time']
    warn_id = users[f'{user.id}']['warn_id']
    emb=discord.Embed(title="warns", color=0x0329e2)
    emb.set_thumbnail(url=ctx.guild.icon_url)
    emb.set_author(name=ctx.author.name, icon_url=ctx.author.avatar_url)
    emb.set_footer(text=ctx.bot.user.name, icon_url=ctx.bot.user.avatar_url)
    emb.add_field(name=f"**Warning count: {warns}\nGiven by:{moderator}\nreaso:{warn_reason}\nAt:{warn_time}\nIDs:{warn_id}**",value="END")




    await ctx.send(embed=emb)
    if not str(user.id) in users:
        await ctx.send(f"he is not warn {user}")
    
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

@client.command(aliases=['كتم'])
@commands.has_permissions(manage_roles=True)
async def mute(ctx, member: discord.Member, time, *, reason=None):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [tempmute], {ctx.author.name}")
    await ctx.message.delete()
    if member.guild_permissions.administrator:
        ifadmin_embed = discord.Embed(title='Member is Administrator!', description=f'The user, {member.mention} can\'t be muted as he/she is an administrator.', color=0xff0000)
        ifadmin_embed.set_author(name='NucleoBot')
        ifadmin_embed.set_footer(text=ctx.author)
        await ctx.channel.send(embed=ifadmin_embed, delete_after=10.0)

    else:
        if discord.utils.get(ctx.guild.roles, name='Muted'):
            muted_role = discord.utils.get(ctx.guild.roles, name='Muted')
        else:
            perms = discord.Permissions(send_messages=True, add_reactions=False, connect=False, speak=False)
            await ctx.guild.create_role(name='Muted', permissions=perms)
            muted_role = discord.utils.get(ctx.guild.roles, name='Muted')

        time_convert = {'s' : 1 , 'm' : 60 , 'h' : 3600 , 'd' : 86400, 'y' : 31536000}
        mute_time = int(time[0]) * time_convert[time[-1]]
#        await ctx.message.delete()
        role_if_muted = discord.utils.find(lambda r: r.name == 'Muted', ctx.guild.roles)

        if role_if_muted in member.roles:
            alreadymuted_embed = discord.Embed(title='Already Muted!', description=f'The user, {member.mention} is already muted for {mute_time} seconds.', color=0xff0000)
            alreadymuted_embed.set_footer(text=ctx.author)
            alreadymuted_embed.set_author(name='NucleoBot')
            await ctx.channel.send(embed=alreadymuted_embed, delete_after=10.0)
        else:
            if reason == None:
                await member.add_roles(muted_role)
                tempmuted_embed = discord.Embed(title='Temporary Mute Successfull!', description=f'{member.mention} has been muted for {mute_time} seconds successfully! \n \n Reason: No reason given.', color=0x4fff4d)
                tempmuted_embed.set_author(name='NucleoBot')
                tempmuted_embed.set_footer(text=ctx.author)
            else:
                await member.add_roles(muted_role)
                tempmuted_embed = discord.Embed(title='Temporary Mute Successfull!', description=f'{member.mention} has been muted for {mute_time} seconds successfully! \n \n Reason: {reason}', color=0x4fff4d)
                tempmuted_embed.set_author(name='NucleoBot')
                tempmuted_embed.set_footer(text=ctx.author)

        await ctx.channel.send(embed=tempmuted_embed, delete_after=10.0)
        await asyncio.sleep(mute_time)
        await member.remove_roles(muted_role)
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
@client.command(aliases=[f'هوية', 'u', 'whois'])#true
async def user(ctx, *, member:discord.Member = None):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [user ,u], {ctx.author.name}")
    if member == None:
            member = ctx.message.author
    embed=discord.Embed(title="User Information", colour=discord.Colour.random())
    embed.set_thumbnail(url=member.avatar_url)
#    embed.add_field(name="**Name**",value=f"**`{member.name}`**")
#    embed.add_field(name="**Nickname**",value=f"**`{member.nick}`**")
    embed.add_field(name="**Joined discord**",value=member.created_at.strftime("**`%a,%b %d,%Y @ %I:%M %p`**"))
    embed.add_field(name="**Joined server**",value=member.joined_at.strftime("**`%a,%b %d,%Y @ %I:%M %p`**"))
    embed.set_footer(text=f"username: {member.name} | nickname: {member.nick}",icon_url=member.avatar_url)
    await ctx.send(embed=embed)
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

@client.command(aliases=['أتصال'])#true
async def ping(ctx):
        print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [ping, p], {ctx.author.name}")
        if round(client.latency * 1000) <= 50:
            embed=discord.Embed(timestamp=ctx.message.created_at,title="PING", description=f":ping_pong: Ping! The ping is **{round(client.latency *1000)}** ms!", color=0x44ff44)
            embed.set_footer(text=f"{ctx.bot.user.name}",icon_url=ctx.bot.user.avatar_url)
            embed.set_thumbnail(url=ctx.guild.icon_url)
            embed.set_author(name=ctx.author.name, icon_url=ctx.author.avatar_url)
        elif round(client.latency * 1000) <= 100:
            embed=discord.Embed(timestamp=ctx.message.created_at,title="PING", description=f":ping_pong: Ping! The ping is **{round(client.latency *1000)}** ms!", color=0xffd000)
            embed.set_footer(text=f"{ctx.bot.user.name}",icon_url=ctx.bot.user.avatar_url)
            embed.set_thumbnail(url=ctx.guild.icon_url)
            embed.set_author(name=ctx.author.name, icon_url=ctx.author.avatar_url)
        elif round(client.latency * 1000) <= 200:
            embed=discord.Embed(timestamp=ctx.message.created_at,title="PING", description=f":ping_pong: Ping! The ping is **{round(client.latency *1000)}** ms!", color=0xff6600)
            embed.set_footer(text=f"{ctx.bot.user.name}",icon_url=ctx.bot.user.avatar_url)
            embed.set_thumbnail(url=ctx.guild.icon_url)
            embed.set_author(name=ctx.author.name, icon_url=ctx.author.avatar_url)
        else:            
            embed=discord.Embed(timestamp=ctx.message.created_at,title="PING", description=f":ping_pong: Ping! The ping is **{round(client.latency *1000)}** ms!", color=0x990000)
            embed.set_footer(text=f"{ctx.bot.user.name}",icon_url=ctx.bot.user.avatar_url)
            embed.set_thumbnail(url=ctx.guild.icon_url)
            embed.set_author(name=ctx.author.name, icon_url=ctx.author.avatar_url)
        await ctx.send(embed=embed)
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

@client.command()#true
async def avatar(ctx, *, member: discord.Member = None):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [avatar], {ctx.author.name}")
    if not member:
        member = ctx.message.author
    em = discord.Embed(title=str(member),url=member.avatar_url,color=0xAE0808)
#    em.set_footer(text=f"{member.name}",icon_url=member.avatar_url)
#    em.add_field(name="Avatar Link")
    em.set_image(url=member.avatar_url)
#    em.set_footer(text=f"at the request of {ctx.author}",icon_url=ctx.avatar_url)
    await ctx.reply(embed=em, mention_author=False)
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

@client.command(aliases = ['مستوى','rank','lvl'])#true
async def level(ctx,member: discord.Member = None):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [level], {ctx.author.name}")
    if not member:
        user = ctx.message.author
        with open('level.json','r') as f:
            users = json.load(f)
        lvl = users[str(ctx.guild.id)][str(user.id)]['level']
        exp = users[str(ctx.guild.id)][str(user.id)]['experience']

        embed = discord.Embed(title = 'Level {}'.format(lvl), description = f"{exp} XP " ,color = discord.Color.green())
        embed.set_author(name = ctx.author, icon_url = ctx.author.avatar_url)
        await ctx.send(embed = embed)
    else:
      with open('level.json','r') as f:
          users = json.load(f)
      lvl = users[str(ctx.guild.id)][str(member.id)]['level']
      exp = users[str(ctx.guild.id)][str(member.id)]['experience']
      embed = discord.Embed(title = 'Level {}'.format(lvl), description = f"{exp} XP" ,color = discord.Color.green())
      embed.set_author(name = member, icon_url = member.avatar_url)

      await ctx.send(embed = embed)
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

@client.command()
@commands.has_permissions(administrator=True)
async def dmall(ctx,*,desc):
    title = f'message from {ctx.message.author}'
    await ctx.send('Sending messages!')
    for members in client.get_all_members():
        embed = discord.Embed(title=title, description=desc)
        await members.send(embed=embed)
        print('Sent a message!')
##img random
@client.command()
async def helpimg(ctx):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [helpimg], {ctx.author.name}")
    await ctx.message.add_reaction("✅")
    embed=discord.Embed(title="help commands", url=f"https://discord.com/api/oauth2/authorize?client_id={client.user.id}&permissions=1644972474359&scope=bot", color=discord.Colour.random())
    embed.set_author(name=f"{client.user}", url=f"https://discord.com/api/oauth2/authorize?client_id={client.user.id}&permissions=1644972474359&scope=bot", icon_url=client.user.avatar_url)
    embed.add_field(name="`dog`", value="**Shows you random dog pictures. The pictures of dogs are very beautiful**")
    embed.add_field(name="`cat`", value="**Shows you random cat pictures. Very beautiful cat pictures**")
    embed.add_field(name="`panda`", value="**Shows you random panda pictures. Very beautiful panda picturese**")
    embed.add_field(name="`fox`", value="**Shows you random fox pictures. Very beautiful fox pictures**")
    embed.add_field(name="`koala`", value="**Shows you random koala pictures. Very beautiful koala pictures**")
    embed.add_field(name="`kiss`", value="**Shows you randomly +18 kissing pictures. very perverted**")    
    await ctx.send(embed=embed)
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

#https://some-random-api.ml/img/dog
@client.command()
async def dog(ctx):
   print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [dog], {ctx.author.name}")
   async with aiohttp.ClientSession() as session:
      request = await session.get('https://some-random-api.ml/img/dog') # Make a request
      dogjson = await request.json() # Convert it to a JSON dictionary
   embed = discord.Embed(title="Doggo!", color=discord.Color.purple()) # Create embed
   embed.set_image(url=dogjson['link']) # Set the embed image to the value of the 'link' key
   await ctx.send(embed=embed) # Send the embed
   print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

#https://some-random-api.ml/img/cat
@client.command()
async def cat(ctx):
   print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [cat], {ctx.author.name}")
   async with aiohttp.ClientSession() as session:
      request = await session.get('https://some-random-api.ml/img/cat') # Make a request
      dogjson = await request.json() # Convert it to a JSON dictionary
   embed = discord.Embed(title="catt!", color=discord.Color.purple()) # Create embed
   embed.set_image(url=dogjson['link']) # Set the embed image to the value of the 'link' key
   await ctx.send(embed=embed) # Send the embed
   print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

#https://some-random-api.ml/img/panda
@client.command()
async def panda(ctx):
   print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [panda], {ctx.author.name}")
   async with aiohttp.ClientSession() as session:
      request = await session.get('https://some-random-api.ml/img/panda') # Make a request
      dogjson = await request.json() # Convert it to a JSON dictionary
   embed = discord.Embed(title="pandda!", color=discord.Color.purple()) # Create embed
   embed.set_image(url=dogjson['link']) # Set the embed image to the value of the 'link' key
   await ctx.send(embed=embed) # Send the embed
   print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

#https://some-random-api.ml/img/fox
@client.command()
async def fox(ctx):
   print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [fox], {ctx.author.name}")
   async with aiohttp.ClientSession() as session:
      request = await session.get('https://some-random-api.ml/img/fox') # Make a request
      dogjson = await request.json() # Convert it to a JSON dictionary
   embed = discord.Embed(title="fox!", color=discord.Color.purple()) # Create embed
   embed.set_image(url=dogjson['link']) # Set the embed image to the value of the 'link' key
   await ctx.send(embed=embed) # Send the embed
   print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

#https://some-random-api.ml/img/koala
@client.command()
async def koala(ctx):
   print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [koala], {ctx.author.name}")
   async with aiohttp.ClientSession() as session:
      request = await session.get('https://some-random-api.ml/img/koala') # Make a request
      dogjson = await request.json() # Convert it to a JSON dictionary
   embed = discord.Embed(title="koalla!", color=discord.Color.purple()) # Create embed
   embed.set_image(url=dogjson['link']) # Set the embed image to the value of the 'link' key
   await ctx.send(embed=embed) # Send the embedt
   print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

@client.command(pass_context=True)
async def kiss(ctx, member: discord.Member):
        """Kiss your senpai/waifu!"""
        print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [kiss], {ctx.author.name}")
        author = ctx.message.author.mention
        mention = member.mention
        
        kiss = "**{0} gave {1} a kiss!**"
        
        choices = ['http://i.imgur.com/0D0Mijk.gif', 'http://i.imgur.com/TNhivqs.gif', 'http://i.imgur.com/3wv088f.gif', 'http://i.imgur.com/7mkRzr1.gif', 'http://i.imgur.com/8fEyFHe.gif', 'https://cdn.weeb.sh/images/BkLQnT_PZ.gif', 'https://cdn.weeb.sh/images/Skv72TuPW.gif', 'https://i.pinimg.com/originals/02/d4/45/02d4453f3eb0a76a87148433395b3ec3.gif']
        image = random.choice(choices)
        embed = discord.Embed(description=kiss.format(author, mention), colour=discord.Colour.blue())
        embed.set_image(url=image)

        await ctx.send(embed=embed)
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

# youtube music
@client.command()
async def helpmusic(ctx):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [helpmusic], {ctx.author.name}")
    await ctx.message.add_reaction("✅")
    embed=discord.Embed(title="Music commands", color=discord.Colour.random())
    embed.set_author(name=f"{client.user}", icon_url=client.user.avatar_url)
    embed.add_field(name="`join`", value="**Joins a voice channel.**")
    embed.add_field(name="`leave`", value="**Clears the queue and leaves the voice channel**")
    embed.add_field(name="`loop`", value="**Loops the currently playing song.**")
    embed.add_field(name="`now`", value="**Displays the currently playing song.**")
    embed.add_field(name="`pause`", value="**Pauses the currently playing song.**")
    embed.add_field(name="`play`", value="**Plays a song.l**")
    embed.add_field(name="`queue`", value="**Shows the player's queue.**")
    embed.add_field(name="`remove`", value="**Removes a song from the queue at a given index.**")
    embed.add_field(name="`resume`", value="**Resumes a currently paused song.**")
    embed.add_field(name="`shuffle`", value="**Shuffles the queue.**")
    embed.add_field(name="`skip`", value="**Vote to skip a song. The requester can automatically skip.**")
    embed.add_field(name="`stop`", value="**Stops playing song and clears the queue.**")
    embed.add_field(name="`summon`", value="**Summons the bot to a voice channel.**")
    embed.add_field(name="`volume`", value="**Sets the volume of the player.**")
    await ctx.send(embed=embed)
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

youtube_dl.utils.bug_reports_message = lambda: ''


class VoiceError(Exception):
    pass


class YTDLError(Exception):
    pass


class YTDLSource(discord.PCMVolumeTransformer):
    YTDL_OPTIONS = {
        'format': 'bestaudio/best',
        'extractaudio': True,
        'audioformat': 'mp3',
        'outtmpl': '%(extractor)s-%(id)s-%(title)s.%(ext)s',
        'restrictfilenames': True,
        'noplaylist': True,
        'nocheckcertificate': True,
        'ignoreerrors': False,
        'logtostderr': False,
        'quiet': True,
        'no_warnings': True,
        'default_search': 'auto',
        'source_address': '0.0.0.0',
    }

    FFMPEG_OPTIONS = {
        'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
        'options': '-vn',
    }

    ytdl = youtube_dl.YoutubeDL(YTDL_OPTIONS)

    def __init__(self, ctx: commands.Context, source: discord.FFmpegPCMAudio, *, data: dict, volume: float = 0.5):
        super().__init__(source, volume)

        self.requester = ctx.author
        self.channel = ctx.channel
        self.data = data

        self.uploader = data.get('uploader')
        self.uploader_url = data.get('uploader_url')
        date = data.get('upload_date')
        self.upload_date = date[6:8] + '.' + date[4:6] + '.' + date[0:4]
        self.title = data.get('title')
        self.thumbnail = data.get('thumbnail')
        self.description = data.get('description')
        self.duration = self.parse_duration(int(data.get('duration')))
        self.tags = data.get('tags')
        self.url = data.get('webpage_url')
        self.views = data.get('view_count')
        self.likes = data.get('like_count')
        self.dislikes = data.get('dislike_count')
        self.stream_url = data.get('url')

    def __str__(self):
        return '**{0.title}** by **{0.uploader}**'.format(self)

    @classmethod
    async def create_source(cls, ctx: commands.Context, search: str, *, loop: asyncio.BaseEventLoop = None):
        loop = loop or asyncio.get_event_loop()

        partial = functools.partial(cls.ytdl.extract_info, search, download=False, process=False)
        data = await loop.run_in_executor(None, partial)

        if data is None:
            raise YTDLError('Couldn\'t find anything that matches `{}`'.format(search))

        if 'entries' not in data:
            process_info = data
        else:
            process_info = None
            for entry in data['entries']:
                if entry:
                    process_info = entry
                    break

            if process_info is None:
                raise YTDLError('Couldn\'t find anything that matches `{}`'.format(search))

        webpage_url = process_info['webpage_url']
        partial = functools.partial(cls.ytdl.extract_info, webpage_url, download=False)
        processed_info = await loop.run_in_executor(None, partial)

        if processed_info is None:
            raise YTDLError('Couldn\'t fetch `{}`'.format(webpage_url))

        if 'entries' not in processed_info:
            info = processed_info
        else:
            info = None
            while info is None:
                try:
                    info = processed_info['entries'].pop(0)
                except IndexError:
                    raise YTDLError('Couldn\'t retrieve any matches for `{}`'.format(webpage_url))

        return cls(ctx, discord.FFmpegPCMAudio(info['url'], **cls.FFMPEG_OPTIONS), data=info)

    @staticmethod
    def parse_duration(duration: int):
        minutes, seconds = divmod(duration, 60)
        hours, minutes = divmod(minutes, 60)
        days, hours = divmod(hours, 24)

        duration = []
        if days > 0:
            duration.append('{} days'.format(days))
        if hours > 0:
            duration.append('{} hours'.format(hours))
        if minutes > 0:
            duration.append('{} minutes'.format(minutes))
        if seconds > 0:
            duration.append('{} seconds'.format(seconds))

        return ', '.join(duration)


class Song:
    __slots__ = ('source', 'requester')

    def __init__(self, source: YTDLSource):
        self.source = source
        self.requester = source.requester

    def create_embed(self):
        embed = (discord.Embed(title='Now playing',
                               description='```css\n{0.source.title}\n```'.format(self),
                               color=discord.Color.blurple())
                 .add_field(name='Duration', value=self.source.duration)
                 .add_field(name='Requested by', value=self.requester.mention)
                 .add_field(name='Uploader', value='[{0.source.uploader}]({0.source.uploader_url})'.format(self))
                 .add_field(name='URL', value='[Click]({0.source.url})'.format(self))
                 .set_thumbnail(url=self.source.thumbnail))

        return embed


class SongQueue(asyncio.Queue):
    def __getitem__(self, item):
        if isinstance(item, slice):
            return list(itertools.islice(self._queue, item.start, item.stop, item.step))
        else:
            return self._queue[item]

    def __iter__(self):
        return self._queue.__iter__()

    def __len__(self):
        return self.qsize()

    def clear(self):
        self._queue.clear()

    def shuffle(self):
        random.shuffle(self._queue)

    def remove(self, index: int):
        del self._queue[index]


class VoiceState:
    def __init__(self, bot: commands.Bot, ctx: commands.Context):
        self.bot = bot
        self._ctx = ctx

        self.current = None
        self.voice = None
        self.next = asyncio.Event()
        self.songs = SongQueue()

        self._loop = False
        self._volume = 100
        self.skip_votes = set()

        self.audio_player = bot.loop.create_task(self.audio_player_task())

    def __del__(self):
        self.audio_player.cancel()

    @property
    def loop(self):
        return self._loop

    @loop.setter
    def loop(self, value: bool):
        self._loop = value

    @property
    def volume(self):
        return self._volume

    @volume.setter
    def volume(self, value: float):
        self._volume = value

    @property
    def is_playing(self):
        return self.voice and self.current

    async def audio_player_task(self):
        while True:
            self.next.clear()

            if not self.loop:
                # Try to get the next song within 3 minutes.
                # If no song will be added to the queue in time,
                # the player will disconnect due to performance
                # reasons.
                try:
                    async with timeout(180):  # 3 minutes
                        self.current = await self.songs.get()
                except asyncio.TimeoutError:
                    self.bot.loop.create_task(self.stop())
                    return

            self.current.source.volume = self._volume
            self.voice.play(self.current.source, after=self.play_next_song)
            await self.current.source.channel.send(embed=self.current.create_embed())

            await self.next.wait()

    def play_next_song(self, error=None):
        if error:
            raise VoiceError(str(error))

        self.next.set()

    def skip(self):
        self.skip_votes.clear()

        if self.is_playing:
            self.voice.stop()

    async def stop(self):
        self.songs.clear()

        if self.voice:
            await self.voice.disconnect()
            self.voice = None


class Music(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        self.voice_states = {}

    def get_voice_state(self, ctx: commands.Context):
        state = self.voice_states.get(ctx.guild.id)
        if not state:
            state = VoiceState(self.bot, ctx)
            self.voice_states[ctx.guild.id] = state

        return state

    def cog_unload(self):
        for state in self.voice_states.values():
            self.bot.loop.create_task(state.stop())

    def cog_check(self, ctx: commands.Context):
        if not ctx.guild:
            raise commands.NoPrivateMessage('This command can\'t be used in DM channels.')

        return True

    async def cog_before_invoke(self, ctx: commands.Context):
        ctx.voice_state = self.get_voice_state(ctx)

    async def cog_command_error(self, ctx: commands.Context, error: commands.CommandError):
        await ctx.send('An error occurred: {}'.format(str(error)))

    @commands.command(name='join', invoke_without_subcommand=True)
    async def _join(self, ctx: commands.Context):
        """Joins a voice channel."""
        print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [join], {ctx.author.name}")

        destination = ctx.author.voice.channel
        if ctx.voice_state.voice:
            await ctx.voice_state.voice.move_to(destination)
            return

        ctx.voice_state.voice = await destination.connect()
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

    @commands.command(name='summon')
    @commands.has_permissions(manage_guild=True)
    async def _summon(self, ctx: commands.Context, *, channel: discord.VoiceChannel = None):
        """Summons the bot to a voice channel.
        If no channel was specified, it joins your channel.
        """
        print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [summon], {ctx.author.name}")

        if not channel and not ctx.author.voice:
            raise VoiceError('You are neither connected to a voice channel nor specified a channel to join.')

        destination = channel or ctx.author.voice.channel
        if ctx.voice_state.voice:
            await ctx.voice_state.voice.move_to(destination)
            return

        ctx.voice_state.voice = await destination.connect()
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

    @commands.command(name='leave', aliases=['disconnect'])
    @commands.has_permissions(manage_guild=True)
    async def _leave(self, ctx: commands.Context):
        """Clears the queue and leaves the voice channel."""
        print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [leave], {ctx.author.name}")

        if not ctx.voice_state.voice:
            return await ctx.send('Not connected to any voice channel.')

        await ctx.voice_state.stop()
        del self.voice_states[ctx.guild.id]
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

    @commands.command(name='volume')
    async def _volume(self, ctx: commands.Context, *, volume: int):
        """Sets the volume of the player."""
        print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [volume], {ctx.author.name}")

        if not ctx.voice_state.is_playing:
            return await ctx.send('Nothing being played at the moment.')

        if 0 > volume > 100:
            return await ctx.send('Volume must be between 0 and 100')

        ctx.voice_state.volume = volume / 100
        await ctx.send('Volume of the player set to {}%'.format(volume))
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

    @commands.command(name='now', aliases=['current', 'playing'])
    async def _now(self, ctx: commands.Context):
        """Displays the currently playing song."""
        await ctx.send(embed=ctx.voice_state.current.create_embed())
        print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [now], {ctx.author.name}")
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

    @commands.command(name='pause')
    @commands.has_permissions(manage_guild=True)
    async def _pause(self, ctx: commands.Context):
        """Pauses the currently playing song."""
        print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [pause], {ctx.author.name}")
        if not ctx.voice_state.is_playing and ctx.voice_state.voice.is_playing():
            ctx.voice_state.voice.pause()
            await ctx.message.add_reaction('⏯')
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

    @commands.command(name='resume')
    @commands.has_permissions(manage_guild=True)
    async def _resume(self, ctx: commands.Context):
        """Resumes a currently paused song."""
        print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [resume], {ctx.author.name}")
        if not ctx.voice_state.is_playing and ctx.voice_state.voice.is_paused():
            ctx.voice_state.voice.resume()
            await ctx.message.add_reaction('⏯')
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

    @commands.command(name='stop')
    @commands.has_permissions(manage_guild=True)
    async def _stop(self, ctx: commands.Context):
        """Stops playing song and clears the queue."""
        print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [stop], {ctx.author.name}")

        ctx.voice_state.songs.clear()

        if not ctx.voice_state.is_playing:
            ctx.voice_state.voice.stop()
            await ctx.message.add_reaction('⏹')
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

    @commands.command(name='skip')
    async def _skip(self, ctx: commands.Context):
        """Vote to skip a song. The requester can automatically skip.
        3 skip votes are needed for the song to be skipped.
        """
        print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [skip], {ctx.author.name}")

        if not ctx.voice_state.is_playing:
            return await ctx.send('Not playing any music right now...')

        voter = ctx.message.author
        if voter == ctx.voice_state.current.requester:
            await ctx.message.add_reaction('⏭')
            ctx.voice_state.skip()
            print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

        elif voter.id not in ctx.voice_state.skip_votes:
            ctx.voice_state.skip_votes.add(voter.id)
            total_votes = len(ctx.voice_state.skip_votes)

            if total_votes >= 3:
                await ctx.message.add_reaction('⏭')
                ctx.voice_state.skip()
                print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
            else:
                await ctx.send('Skip vote added, currently at **{}/3**'.format(total_votes))

        else:
            await ctx.send('You have already voted to skip this song.')

    @commands.command(name='queue')
    async def _queue(self, ctx: commands.Context, *, page: int = 1):
        """Shows the player's queue.
        You can optionally specify the page to show. Each page contains 10 elements.
        """
        print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [queue], {ctx.author.name}")

        if len(ctx.voice_state.songs) == 0:
            return await ctx.send('Empty queue.')

        items_per_page = 10
        pages = math.ceil(len(ctx.voice_state.songs) / items_per_page)

        start = (page - 1) * items_per_page
        end = start + items_per_page

        queue = ''
        for i, song in enumerate(ctx.voice_state.songs[start:end], start=start):
            queue += '`{0}.` [**{1.source.title}**]({1.source.url})\n'.format(i + 1, song)

        embed = (discord.Embed(description='**{} tracks:**\n\n{}'.format(len(ctx.voice_state.songs), queue))
                 .set_footer(text='Viewing page {}/{}'.format(page, pages)))
        await ctx.send(embed=embed)
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

    @commands.command(name='shuffle')
    async def _shuffle(self, ctx: commands.Context):
        """Shuffles the queue."""
        print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [shuffle], {ctx.author.name}")

        if len(ctx.voice_state.songs) == 0:
            return await ctx.send('Empty queue.')

        ctx.voice_state.songs.shuffle()
        await ctx.message.add_reaction('✅')
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

    @commands.command(name='remove')
    async def _remove(self, ctx: commands.Context, index: int):
        """Removes a song from the queue at a given index."""
        print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [remove], {ctx.author.name}")

        if len(ctx.voice_state.songs) == 0:
            return await ctx.send('Empty queue.')

        ctx.voice_state.songs.remove(index - 1)
        await ctx.message.add_reaction('✅')
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

    @commands.command(name='loop')
    async def _loop(self, ctx: commands.Context):
        """Loops the currently playing song.
        Invoke this command again to unloop the song.
        """
        print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [loop], {ctx.author.name}")

        if not ctx.voice_state.is_playing:
            return await ctx.send('Nothing being played at the moment.')

        # Inverse boolean value to loop and unloop.
        ctx.voice_state.loop = not ctx.voice_state.loop
        await ctx.message.add_reaction('✅')
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

    @commands.command(name='play')
    async def _play(self, ctx: commands.Context, *, search: str):
        """Plays a song.
        If there are songs in the queue, this will be queued until the
        other songs finished playing.
        This command automatically searches from various sites if no URL is provided.
        A list of these sites can be found here: https://rg3.github.io/youtube-dl/supportedsites.html
        """
        print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [play], {ctx.author.name}")

        if not ctx.voice_state.voice:
            await ctx.invoke(self._join)

        async with ctx.typing():
            try:
                source = await YTDLSource.create_source(ctx, search, loop=self.bot.loop)
            except YTDLError as e:
                await ctx.send('An error occurred while processing this request: {}'.format(str(e)))
            else:
                song = Song(source)

                await ctx.voice_state.songs.put(song)
                await ctx.send('Enqueued {}'.format(str(source)))
                print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

    @_join.before_invoke
    @_play.before_invoke
    async def ensure_voice_state(self, ctx: commands.Context):
        if not ctx.author.voice or not ctx.author.voice.channel:
            raise commands.CommandError('You are not connected to any voice channel.')

        if ctx.voice_client:
            if ctx.voice_client.channel != ctx.author.voice.channel:
                raise commands.CommandError('Bot is already in a voice channe')
client.add_cog(Music(client))


# tiek
@client.command()
async def helpticket(ctx):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [helpticket], {ctx.author.name}")
    with open("data.json") as f:
        data = json.load(f)
    
    valid_user = False

    for role_id in data["verified-roles"]:
        try:
            if ctx.guild.get_role(role_id) in ctx.author.roles:
                valid_user = True
        except:
            pass
    
    if ctx.author.guild_permissions.administrator or valid_user:

        em = discord.Embed(title="Auroris Tickets Help", description="", color=0x00a8ff)
        em.add_field(name="`ticket <message>`", value="This creates a new ticket. Add any words after the command if you'd like to send a message when we initially create your ticket.")
        em.add_field(name="`close`", value="Use this to close a ticket. This command only works in ticket channels.")
        em.add_field(name="`addaccess <role_id>`", value="This can be used to give a specific role access to all tickets. This command can only be run if you have an admin-level role for this bot.")
        em.add_field(name="`delaccess <role_id>`", value="This can be used to remove a specific role's access to all tickets. This command can only be run if you have an admin-level role for this bot.")
        em.add_field(name="`addpingedrole <role_id>`", value="This command adds a role to the list of roles that are pinged when a new ticket is created. This command can only be run if you have an admin-level role for this bot.")
        em.add_field(name="`delpingedrole <role_id>`", value="This command removes a role from the list of roles that are pinged when a new ticket is created. This command can only be run if you have an admin-level role for this bot.")
        em.add_field(name="`addadminrole <role_id>`", value="This command gives all users with a specific role access to the admin-level commands for the bot, such as `.addpingedrole` and `.addaccess`. This command can only be run by users who have administrator permissions for the entire server.")
        em.add_field(name="`deladminrole <role_id>`", value="This command removes access for all users with the specified role to the admin-level commands for the bot, such as `.addpingedrole` and `.addaccess`. This command can only be run by users who have administrator permissions for the entire server.")
        em.set_footer(text="advanced Development")
        await ctx.message.add_reaction("✅")
        await ctx.send(embed=em)
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
    else:

        em = discord.Embed(title = "Auroris Tickets Help", description ="", color = 0x00a8ff)
        em.add_field(name="`ticket <message>`", value="This creates a new ticket. Add any words after the command if you'd like to send a message when we initially create your ticket.")
        em.add_field(name="`close`", value="Use this to close a ticket. This command only works in ticket channels.")
        em.set_footer(text="Auroris Development")

        await ctx.send(embed=em)
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

@client.command(name='ticket')
async def ticket(ctx, *, args = None):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [ticket], {ctx.author.name}")

    await client.wait_until_ready()

    if args == None:
        message_content = "Please wait, we will be with you shortly!"
    
    else:
        message_content = "".join(args)

    with open("data.json") as f:
        data = json.load(f)

    ticket_number = int(data["ticket-counter"])
    ticket_number += 1

    ticket_channel = await ctx.guild.create_text_channel("ticket-{}".format(ticket_number))
    await ticket_channel.set_permissions(ctx.guild.get_role(ctx.guild.id), send_messages=False, read_messages=False)

    for role_id in data["valid-roles"]:
        role = ctx.guild.get_role(role_id)

        await ticket_channel.set_permissions(role, send_messages=True, read_messages=True, add_reactions=True, embed_links=True, attach_files=True, read_message_history=True, external_emojis=True)
    
    await ticket_channel.set_permissions(ctx.author, send_messages=True, read_messages=True, add_reactions=True, embed_links=True, attach_files=True, read_message_history=True, external_emojis=True)

    em = discord.Embed(title="New ticket from {}#{}".format(ctx.author.name, ctx.author.discriminator), description= "{}".format(message_content), color=0x00a8ff)

    await ticket_channel.send(embed=em)

    pinged_msg_content = ""
    non_mentionable_roles = []

    if data["pinged-roles"] != []:

        for role_id in data["pinged-roles"]:
            role = ctx.guild.get_role(role_id)

            pinged_msg_content += role.mention
            pinged_msg_content += " "

            if role.mentionable:
                pass
            else:
                await role.edit(mentionable=True)
                non_mentionable_roles.append(role)
        
        await ticket_channel.send(pinged_msg_content)

        for role in non_mentionable_roles:
            await role.edit(mentionable=False)
    
    data["ticket-channel-ids"].append(ticket_channel.id)

    data["ticket-counter"] = int(ticket_number)
    with open("data.json", 'w') as f:
        json.dump(data, f)
    
    created_em = discord.Embed(title="Auroris Tickets", description="Your ticket has been created at {}".format(ticket_channel.mention), color=0x00a8ff)
    
    await ctx.send(embed=created_em)
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

@client.command()
async def close(ctx):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [close], {ctx.author.name}")

    with open('data.json') as f:
        data = json.load(f)

    if ctx.channel.id in data["ticket-channel-ids"]:

        channel_id = ctx.channel.id

        def check(message):
            return message.author == ctx.author and message.channel == ctx.channel and message.content.lower() == "close"

        try:

            em = discord.Embed(title="Auroris Tickets", description="Are you sure you want to close this ticket? Reply with `close` if you are sure.", color=0x00a8ff)
        
            await ctx.send(embed=em)
            await client.wait_for('message', check=check, timeout=60)
            await ctx.channel.delete()

            index = data["ticket-channel-ids"].index(channel_id)
            del data["ticket-channel-ids"][index]

            with open('data.json', 'w') as f:
                json.dump(data, f)
        
        except asyncio.TimeoutError:
            em = discord.Embed(title="Auroris Tickets", description="You have run out of time to close this ticket. Please run the command again.", color=0x00a8ff)
            await ctx.send(embed=em)
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

        

@client.command()
async def addaccess(ctx, role_id=None):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [addaccess], {ctx.author.name}")

    with open('data.json') as f:
        data = json.load(f)
    
    valid_user = False

    for role_id in data["verified-roles"]:
        try:
            if ctx.guild.get_role(role_id) in ctx.author.roles:
                valid_user = True
        except:
            pass
    
    if valid_user or ctx.author.guild_permissions.administrator:
        role_id = int(role_id)

        if role_id not in data["valid-roles"]:

            try:
                role = ctx.guild.get_role(role_id)

                with open("data.json") as f:
                    data = json.load(f)

                data["valid-roles"].append(role_id)

                with open('data.json', 'w') as f:
                    json.dump(data, f)
                
                em = discord.Embed(title="Auroris Tickets", description="You have successfully added `{}` to the list of roles with access to tickets.".format(role.name), color=0x00a8ff)

                await ctx.send(embed=em)
                print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

            except:
                em = discord.Embed(title="Auroris Tickets", description="That isn't a valid role ID. Please try again with a valid role ID.")
                await ctx.send(embed=em)
            print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
        
        else:
            em = discord.Embed(title="Auroris Tickets", description="That role already has access to tickets!", color=0x00a8ff)
            await ctx.send(embed=em)
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
    
    else:
        em = discord.Embed(title="Auroris Tickets", description="Sorry, you don't have permission to run that command.", color=0x00a8ff)
        await ctx.send(embed=em)
    print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

@client.command()
async def delaccess(ctx, role_id=None):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [delaccess], {ctx.author.name}")

    with open('data.json') as f:
        data = json.load(f)
    
    valid_user = False

    for role_id in data["verified-roles"]:
        try:
            if ctx.guild.get_role(role_id) in ctx.author.roles:
                valid_user = True
        except:
            pass

    if valid_user or ctx.author.guild_permissions.administrator:

        try:
            role_id = int(role_id)
            role = ctx.guild.get_role(role_id)

            with open("data.json") as f:
                data = json.load(f)

            valid_roles = data["valid-roles"]

            if role_id in valid_roles:
                index = valid_roles.index(role_id)

                del valid_roles[index]

                data["valid-roles"] = valid_roles

                with open('data.json', 'w') as f:
                    json.dump(data, f)

                em = discord.Embed(title="Auroris Tickets", description="You have successfully removed `{}` from the list of roles with access to tickets.".format(role.name), color=0x00a8ff)

                await ctx.send(embed=em)
                print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
        
            else:
                
                em = discord.Embed(title="Auroris Tickets", description="That role already doesn't have access to tickets!", color=0x00a8ff)
                await ctx.send(embed=em)
                print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

        except:
            em = discord.Embed(title="Auroris Tickets", description="That isn't a valid role ID. Please try again with a valid role ID.")
            await ctx.send(embed=em)
            print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
    
    else:
        em = discord.Embed(title="Auroris Tickets", description="Sorry, you don't have permission to run that command.", color=0x00a8ff)
        await ctx.send(embed=em)
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

@client.command()
async def addpingedrole(ctx, role_id=None):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [addpingedrole], {ctx.author.name}")

    with open('data.json') as f:
        data = json.load(f)
    
    valid_user = False

    for role_id in data["verified-roles"]:
        try:
            if ctx.guild.get_role(role_id) in ctx.author.roles:
                valid_user = True
        except:
            pass
    
    if valid_user or ctx.author.guild_permissions.administrator:

        role_id = int(role_id)

        if role_id not in data["pinged-roles"]:

            try:
                role = ctx.guild.get_role(role_id)

                with open("data.json") as f:
                    data = json.load(f)

                data["pinged-roles"].append(role_id)

                with open('data.json', 'w') as f:
                    json.dump(data, f)

                em = discord.Embed(title="Auroris Tickets", description="You have successfully added `{}` to the list of roles that get pinged when new tickets are created!".format(role.name), color=0x00a8ff)

                await ctx.send(embed=em)
                print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

            except:
                em = discord.Embed(title="Auroris Tickets", description="That isn't a valid role ID. Please try again with a valid role ID.")
                await ctx.send(embed=em)
                print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
        
        else:
            em = discord.Embed(title="Auroris Tickets", description="That role already receives pings when tickets are created.", color=0x00a8ff)
            await ctx.send(embed=em)
            print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
    
    else:
        em = discord.Embed(title="Auroris Tickets", description="Sorry, you don't have permission to run that command.", color=0x00a8ff)
        await ctx.send(embed=em)
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
 
@client.command()
async def delpingedrole(ctx, role_id=None):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [delpingedrole], {ctx.author.name}")

    with open('data.json') as f:
        data = json.load(f)
    
    valid_user = False

    for role_id in data["verified-roles"]:
        try:
            if ctx.guild.get_role(role_id) in ctx.author.roles:
                valid_user = True
        except:
            pass
    
    if valid_user or ctx.author.guild_permissions.administrator:

        try:
            role_id = int(role_id)
            role = ctx.guild.get_role(role_id)

            with open("data.json") as f:
                data = json.load(f)

            pinged_roles = data["pinged-roles"]

            if role_id in pinged_roles:
                index = pinged_roles.index(role_id)

                del pinged_roles[index]

                data["pinged-roles"] = pinged_roles

                with open('data.json', 'w') as f:
                    json.dump(data, f)

                em = discord.Embed(title="Auroris Tickets", description="You have successfully removed `{}` from the list of roles that get pinged when new tickets are created.".format(role.name), color=0x00a8ff)
                await ctx.send(embed=em)
                print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
    
            else:
                em = discord.Embed(title="Auroris Tickets", description="That role already isn't getting pinged when new tickets are created!", color=0x00a8ff)
                await ctx.send(embed=em)
                print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

        except:
            em = discord.Embed(title="Auroris Tickets", description="That isn't a valid role ID. Please try again with a valid role ID.")
            await ctx.send(embed=em)
            print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
   
    else:
        em = discord.Embed(title="Auroris Tickets", description="Sorry, you don't have permission to run that command.", color=0x00a8ff)
        await ctx.send(embed=em)
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")


@client.command()
@commands.has_permissions(administrator=True)
async def addadminrole(ctx, role_id=None):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [addadminrole], {ctx.author.name}")

    try:
        role_id = int(role_id)
        role = ctx.guild.get_role(role_id)

        with open("data.json") as f:
            data = json.load(f)

        data["verified-roles"].append(role_id)

        with open('data.json', 'w') as f:
            json.dump(data, f)
        
        em = discord.Embed(title="Auroris Tickets", description="You have successfully added `{}` to the list of roles that can run admin-level commands!".format(role.name), color=0x00a8ff)
        await ctx.send(embed=em)
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

    except:
        em = discord.Embed(title="Auroris Tickets", description="That isn't a valid role ID. Please try again with a valid role ID.")
        await ctx.send(embed=em)
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

@client.command()
@commands.has_permissions(administrator=True)
async def deladminrole(ctx, role_id=None):
    print(f"[{Fore.GREEN}connection{Fore.RESET}] He ordered the bot. The thing is [deladminrole], {ctx.author.name}")

    try:
        role_id = int(role_id)
        role = ctx.guild.get_role(role_id)

        with open("data.json") as f:
            data = json.load(f)

        admin_roles = data["verified-roles"]

        if role_id in admin_roles:
            index = admin_roles.index(role_id)

            del admin_roles[index]

            data["verified-roles"] = admin_roles

            with open('data.json', 'w') as f:
                json.dump(data, f)
            
            em = discord.Embed(title="Auroris Tickets", description="You have successfully removed `{}` from the list of roles that get pinged when new tickets are created.".format(role.name), color=0x00a8ff)

            await ctx.send(embed=em)
            print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")
    
        else:
            em = discord.Embed(title="Auroris Tickets", description="That role isn't getting pinged when new tickets are created!", color=0x00a8ff)
            await ctx.send(embed=em)
            print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

    except:
        em = discord.Embed(title="Auroris Tickets", description="That isn't a valid role ID. Please try again with a valid role ID.")
        await ctx.send(embed=em)
        print(f"[{Fore.GREEN}Bot{Fore.RESET}] It's complete.")

client.run(tokens)
